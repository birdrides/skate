@file:Suppress("unused")

package skate

import skate.generator.DeleteStatement
import skate.generator.Dialect
import kotlin.reflect.KClass
import kotlin.reflect.KProperty1
import kotlin.reflect.full.findAnnotation
import kotlin.reflect.full.memberProperties

// Insert
inline fun <reified T : Any> KClass<T>.insert(vararg properties: KProperty1<T, *>): InsertWithoutSource<T> {
  val table = Table(this)
  val insertProperties = if (properties.isEmpty()) {
    T::class.memberProperties.filter { it.findAnnotation<Transient>() == null }
  } else {
    properties.toList()
  }
  return InsertWithoutSource(
    table,
    insertProperties.map { property ->
      InsertField(Column(property, table), Attribute(property, table))
    }
  )
}

fun <T : Any> InsertWithoutSource<T>.values(vararg rows: T): Insert<T> =
  Insert(this, InsertSourceFromData(rows.toList()))

fun <T : Any> InsertWithoutSource<T>.values(rows: List<T>): Insert<T> = Insert(this, InsertSourceFromData(rows))

fun <T : Any> InsertWithoutSource<T>.from(sourceQuery: Query): Insert<T> =
  Insert(this, InsertSourceFromSelect(sourceQuery))

inline fun <reified TSource : Any> InsertWithoutSource<*>.from(callback: TableAlias<TSource>.() -> Query): Insert<*> {
  val alias = TableAlias(TSource::class, "autogenerated_alias_insert_" + TSource::class.simpleName)
  return this.from(callback(alias))
}

fun <T : Any> Insert<T>.returning(vararg properties: KProperty1<T, *>) = InsertWithProjections(
  this,
  properties.map {
    Projection(
      Column(it, this.insert.table),
      null
    )
  }
)

fun <T : Any> Insert<T>.returning(vararg projections: Projection) = InsertWithProjections(this, projections.toList())
fun <T : Any> Insert<T>.returningAll() = InsertWithProjections(this, listOf(Projection(All<Any>())))

fun <T : Any> Insert<T>.generate(dialect: Dialect) = dialect.generate(this)
fun <T : Any> InsertWithProjections<T>.generate(dialect: Dialect) = dialect.generate(this)

// Upsert

fun <T : Any> Insert<T>.onConflict(vararg conflictedColumns: KProperty1<T, Any?>): InsertConflict<T> {
  return InsertConflict(this, conflictedColumns.map { Column(it, this.insert.table) })
}

fun <T : Any> InsertConflict<T>.doNothing(): InsertConflictDoNothing<T> {
  return InsertConflictDoNothing(this)
}

fun <T : Any> InsertConflict<T>.update(vararg columns: KProperty1<T, Any?>): InsertConflictUpdate<T> {
  return InsertConflictUpdate(this, columns.map { Column(it, this.insert.insert.table) })
}

fun <T : Any> InsertConflictAction<T>.returning(vararg properties: KProperty1<T, *>) =
  InsertConflictActionWithProjections(
    this,
    properties.map {
      Projection(
        Column(it, this.conflict.insert.insert.table),
        null
      )
    }
  )

fun <T : Any> InsertConflictAction<T>.returning(vararg projections: Projection) =
  InsertConflictActionWithProjections(this, projections.toList())

fun <T : Any> InsertConflictAction<T>.returningAll() =
  InsertConflictActionWithProjections(this, listOf(Projection(All<Any>())))

fun <T : Any> InsertConflictAction<T>.generate(dialect: Dialect) = dialect.generate(this)
fun <T : Any> InsertConflictActionWithProjections<T>.generate(dialect: Dialect) = dialect.generate(this)

// Update

// Just as in QueryExtensions, we're mirroring an API surface area between KClass and TableAlias.  In the future we
// should probably consolidate by requiring a call that wraps the KClass:
//
// with<Nest>().update(...).from(...).where(...)

inline fun <reified T : Any> KClass<T>.update(vararg fields: UpdateField<T>?): UpdateWithoutWhere<T> {
  val table = Table(this)
  return UpdateWithoutWhere(table, listOfNotNull(*fields), EmptyUpdateFrom)
}

inline fun <reified T : Any> TableAlias<T>.update(vararg fields: UpdateField<T>?): UpdateWithoutWhere<T> {
  val table = Table(type, alias)
  return UpdateWithoutWhere(table, listOfNotNull(*fields), EmptyUpdateFrom)
}

inline fun <reified T : Any> KClass<T>.updateAll(vararg fields: UpdateField<T>?): Update<T> {
  val table = Table(this)
  return Update(table, fields.filterNotNull(), null)
}

inline fun <reified T : Any> TableAlias<T>.updateAll(vararg fields: UpdateField<T>?): Update<T> {
  val table = Table(type, alias)
  return Update(table, fields.filterNotNull(), null)
}

inline fun <reified T : Any, R> KProperty1<T, R?>.nullable(): UpdateField<T> {
  val table = Table(T::class)
  return UpdateField(Column(this, table), Value<R?>(null))
}

inline infix fun <reified T : Any, R> KProperty1<T, R?>.to(expression: Expression<R>?): UpdateField<T>? {
  val table = Table(T::class)
  return if (expression == null) {
    null
  } else {
    return UpdateField(Column(this, table), expression)
  }
}

inline infix fun <reified T : Any, R> KProperty1<T, R?>.to(value: R?): UpdateField<T>? {
  val table = Table(T::class)
  return if (value == null) {
    null
  } else {
    UpdateField(Column(this, table), Value(value))
  }
}

inline infix fun <reified T : Any, R> UpdateField<T>.to(value: R?): UpdateField<T> {
  return UpdateField(column, Value(value))
}

fun <T : Any> UpdateWithoutWhere<T>.where(condition: Expression<Boolean>): Update<T> =
  Update(this.table, this.fields, condition, this.fromClause)

fun <T : Any> Update<T>.where(condition: Expression<Boolean>): Update<T> = this.copy(whereClause = condition)

// UPDATE ... SET ... FROM Table, OtherTable WHERE ...
//                         ^^^^^^^^^^^^^^^^^
fun <T : Any> UpdateWithoutWhere<T>.from(vararg sources: Table<*>): UpdateWithoutWhere<T> =
  UpdateWithoutWhere(this.table, this.fields, UpdateFromTableList(sources.toList()))

// UPDATE ... SET ... FROM Table t, OtherTable ot WHERE ...
//                         ^^^^^^^^^^^^^^^^^^^^^^
fun <T : Any> UpdateWithoutWhere<T>.from(vararg sources: TableAlias<*>): UpdateWithoutWhere<T> =
  UpdateWithoutWhere(this.table, this.fields, UpdateFromTableAliasList(sources.toList()))

// UPDATE ... SET ... FROM (SELECT ... FROM ... WHERE ...) alias WHERE ...
//                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Skate vNext: Semantically this alias should be a 'SubqueryAlias' instead
fun <T : Any> UpdateWithoutWhere<T>.from(fromClause: Query, alias: TableAlias<*>): UpdateWithoutWhere<T> =
  UpdateWithoutWhere(this.table, this.fields, UpdateFromSubQuery(alias, fromClause))

// Generates same SQL as previous, but "just generate a subQ alias identifier for me, I don't care"
fun <T : Any> UpdateWithoutWhere<T>.from(query: Query): UpdateWithoutWhere<T> =
  UpdateWithoutWhere(this.table, this.fields, UpdateFromSubQueryWithIgnoredAlias(query))

fun <T : Any> Update<T>.returning(vararg properties: KProperty1<T, *>) = this.copy(
  projections = properties.map {
    Projection(
      Column(it, this.table),
      null
    )
  }
)

fun <T : Any> Update<T>.returning(vararg projections: Projection) = this.copy(projections = projections.toList())
fun <T : Any> Update<T>.returning(vararg intoFields: IntoField<*, *>) = this.copy(intoFields = intoFields.toList())
fun <T : Any> Update<T>.returningAll() = this.copy(projections = listOf(Projection(All<Any>())))

fun <T : Any> Update<T>.generate(dialect: Dialect) = dialect.generate(this)

inline fun <reified T : Any> Delete<T>.generate(dialect: Dialect): DeleteStatement {
  return dialect.generate(this)
}

inline fun <reified T : Any> KClass<T>.delete(): Delete<T> {
  val table = Table(T::class)
  return Delete(table)
}

fun <T : Any> Delete<T>.where(condition: Expression<Boolean>): Delete<T> {
  return Delete(this.table, condition)
}
